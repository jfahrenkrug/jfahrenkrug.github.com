--- 
name: javascript-this-is-not-always-what-youd
layout: ../layouts/OldPostLayout.astro
title: "JavaScript 'this' is Not Always What You'd Think: Use Closures"
time: 2008-07-30 09:56:00.007000 Z
categories: 
- JavaScript
- Programming
- OpenSocial
---
JavaScript has quite a few design flaws (see the chapters "Awful Parts" and "Bad Parts" in Douglas Crockford's great book "<a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742/ref=pd_bbs_sr_1?ie=UTF8&amp;s=books&amp;qid=1217246566&amp;sr=1-1">JavaScript: The Good Parts</a>"). One bad part to look out for is <a href="http://bitstructures.com/2007/11/javascript-method-callbacks">described in detail here</a>. To sum it up: "this" is not always bound to what you'd think. Take this example:<br /><pre class="prettyprint"><br />var myObj = {<br />  value_a : 'Soylent Green',<br />  value_b : 'is People',<br />  printA: function() {<br />   alert(this.value_a);<br />  }<br />}<br /><br />//if you call the method directly on the object, "this" is bound to the object as expected:<br />myObj.printA(); // --> "Soylent Green"<br /><br />//if you don't invoke it on the object, "this" is bound to the JavaScript global object. This is a very bad part<br />var print_method = myObj.printA;<br />print_method(); // --> undefined<br /></pre><br />This can cause lots of wailing and gnashing of teeth. I ran into this in an OpenSocial application. OpenSocial uses lots of callbacks which take functions as parameters. In that case, exactly the problem occurs that the above code demonstrates.<br />What can we do? We can use one of JavaScript's beautiful features: Closures. I'll just show you a piece of code that demonstrates what they do:<br /><pre class="prettyprint"><br />var closure = function() {<br />  var a_value_that_lives_on_after_this_method_finishes = 'I am alive!';<br /><br />  return function() {<br />    //this function will be returned but it can still access that long variable name up there<br />    alert(a_value_that_lives_on_after_this_method_finishes);<br />  };<br />}(); //notice that we create the anonymous function and invoke it right away.<br /><br />//we can now call the returned function and behold! it can access that long variable name!<br />closure();<br /></pre><br />Great! We can use that (no pun intended, read on...) to solve our "this" problem. Look at this code. It it a super simple OpenSocial application. You can run it in your container when you point it to this URL: <a href="http://opensocial-friendscolor.googlecode.com/svn/trunk/thistest/thistest.xml">http://opensocial-friendscolor.googlecode.com/svn/trunk/thistest/thistest.xml</a><br />Here's the code:<br /><pre class="prettyprint"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;Module&gt;<br />&lt;ModulePrefs<br />     title="JavaScript this Test"<br />     height="600"&gt;<br />    &lt;Require feature="opensocial-0.7"/&gt;<br />&lt;/ModulePrefs&gt;<br /><br /><br />&lt;Content type="html"&gt;<br />    &lt;![CDATA[<br />        &lt;script&gt;<br />            // we are creating and calling a function that returns an object literal.<br />            // before returning it, we assign it to the variable "that".<br />            // JavaScript closures enable us to still reference "that" even after the function ended.<br />            // That way we always have a way to access our object reliably.<br />            var thistest = function() {<br />              var that = {<br />                string_one : 'Soylent Green',<br />                string_two : 'is People!!!',<br />                printOne : function() {<br />                  console.log('Printing string one: ' + that.string_one);<br />                },<br />        <br />                printTwo : function() {<br />                  console.log('Printing string two: ' + that.string_two);<br />                },<br />        <br />                printBoth : function() {<br />                  that.printOne();<br />                  that.printTwo();<br />                },<br />          <br />                getViewer : function() {<br />                  var req = opensocial.newDataRequest();<br />                 var params = {};<br /><br />                  params[opensocial.DataRequest.PeopleRequestFields.PROFILE_DETAILS]=[opensocial.Person.Field.GENDER, opensocial.Person.Field.PROFILE_URL];<br /><br />                  req.add(req.newFetchPersonRequest("VIEWER", params), "viewer");<br /><br />                  req.send(that.getViewerCallback);<br />                },<br />          <br />                getViewerCallback: function() {<br />                  //I don't care about the viewer data, just about what value "this" has<br />                  console.log('in getViewerCallback');<br />                  console.log('this:');<br />                  console.log(this);<br />                  console.log('that:');<br />                  console.log(that);<br />                  that.printBoth();<br />                },<br />        <br />                runTest : function() {<br />                  console.log('in runTest');<br />                  console.log('this:');<br />                  console.log(this);<br />                  console.log('that:');<br />                  console.log(that);<br />                  that.printBoth();<br />                  that.getViewer();<br />                },<br />        <br />                runOnLoadTest : function() {<br />                  console.log('in runOnLoadTest');<br />                  console.log('this:');<br />                  console.log(this);<br />                  console.log('that:');<br />                  console.log(that);<br />                  that.printBoth();<br />                  that.getViewer();<br />                }<br />              };<br />        <br />              return that;<br />            }(); //notice that the function is invoked right away<br />    <br />            gadgets.util.registerOnLoadHandler(thistest.runOnLoadTest);<br />        &lt;/script&gt;<br /><br />        &lt;h2&gt;JavaScript this Test&lt;/h2&gt;<br />        &lt;p&gt;This demo shows that the JavaScript 'this' object is not bound to what you'd expect if a method is called with registerOnLoadHandler, except if you use a closure. Watch your console.&lt;/p&gt;<br />    <br />    <br />        &lt;input type="button" value="Run Test directly, without the onLoadHandler" onclick="thistest.runTest();"/&gt;<br />        &lt;p&gt;(2008, &lt;a href="http://blog.springenwerk.com"&gt;Johannes Fahrenkrug&lt;/a&gt;)&lt;/p&gt;<br />    ]]&gt;<br />&lt;/Content&gt;<br />&lt;/Module&gt;<br /></pre><br /><br />If you run this within Orkut, this will be show up in your Firebug console:<br /><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 596px; height: 272px;" src="http://2.bp.blogspot.com/_-dK4R3d1lbc/SJBFDjIJcII/AAAAAAAAAhQ/mIrAu733B_0/s400/Picture+1.png" alt="" /><br /><br />You can see that "this" doesn't have the value we'd want it to have: our thistest object. But by using a closure and assigning our object literal to the variable "that" we can solve the problem. Now we can always access our thistest object by saying "that" instead of "this".
